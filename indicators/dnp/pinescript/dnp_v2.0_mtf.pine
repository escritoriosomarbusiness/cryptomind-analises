//@version=6
indicator("DNP v2.0 by CryptoMind IA", shorttitle="DNP v2.0", overlay=true)

// ============================================================================
// INPUTS CONFIGURÁVEIS
// ============================================================================

// Didi Index
curtaLength = input.int(3, "Didi Curta", minval=1, group="Didi Index")
mediaLength = input.int(8, "Didi Média", minval=1, group="Didi Index")
longaLength = input.int(20, "Didi Longa", minval=1, group="Didi Index")
maxDistanceFromAxis = input.float(0.15, "Distância Máx. do Eixo (%)", minval=0.05, maxval=2.0, step=0.05, group="Didi Index", tooltip="5min: 0.10 | 15min: 0.20 | 1H: 0.30 | 4H: 0.50")

// ADX/DMI
adxLength = input.int(8, "ADX Length", minval=1, group="ADX/DMI")
adxSmoothing = input.int(8, "ADX Smoothing", minval=1, group="ADX/DMI")
adxMinValue = input.float(15.0, "ADX Mínimo", minval=10, maxval=50, step=1, group="ADX/DMI")
adxMinSlope = input.float(1.5, "Inclinação Mínima ADX", minval=0.5, maxval=10.0, step=0.5, group="ADX/DMI", tooltip="5min: 1.5 | 15min: 2.5 | 1H: 3.0 | 4H: 4.0")

// Bollinger Bands
bbLength = input.int(8, "BB Length", minval=1, group="Bollinger Bands")
bbMult = input.float(2.0, "BB Mult", minval=0.1, maxval=5, step=0.1, group="Bollinger Bands")
bbExpansionLookback = input.int(7, "Períodos para Média BB", minval=3, maxval=10, group="Bollinger Bands", tooltip="Candles anteriores para calcular expansão")
bbExpansionRatio = input.float(1.5, "Razão Mínima de Expansão", minval=1.0, maxval=3.0, step=0.1, group="Bollinger Bands", tooltip="REMI mínimo para validar")
bbExpansionMaxRatio = input.float(3.0, "Razão Máxima de Expansão", minval=1.0, maxval=5.0, step=0.1, group="Bollinger Bands", tooltip="REMI máximo aceito - evita volatilidade extrema")

// Pivots
pivotLookback = input.int(10, "Pivot Lookback", minval=3, maxval=10, group="Pivots S/R")
pivotBreakMethod = input.string("Por Fechamento (Close)", "Validação Pivot Breakout", options=["Por Pavio (High/Low)", "Por Fechamento (Close)"], group="Pivots S/R", tooltip="Pavio: valida por HIGH/LOW | Fechamento: valida por CLOSE")

// Setup
setupWindow = input.int(3, "Janela de Construção (candles)", minval=2, maxval=10, group="Setup", tooltip="Máximo de candles para todas condições se alinharem")
maxWickPercent = input.float(0.40, "Pavio Máximo (%)", minval=0.1, maxval=0.9, step=0.05, group="Setup", tooltip="Pavio não pode ser maior que X% do corpo")
slMethod = input.string("Pivots (S/R)", "Método Stop Loss", options=["3 Candles Anteriores", "Pivots (S/R)"], group="Setup", tooltip="3 Candles: SL no menor/maior dos 3 anteriores | Pivots: SL no suporte/resistência")

// Dashboard
showDashboard = input.bool(true, "Mostrar Dashboard", group="Visual")

// ============================================================================
// FILTRO DE TENDÊNCIA MULTI-TIMEFRAME (MTF) - NOVO v2.0
// ============================================================================

// Detectar timeframe superior (fractal superior)
getHigherTimeframe() =>
    currentTF = timeframe.period
    currentTF == "1" ? "15" : currentTF == "5" ? "60" : currentTF == "15" ? "240" : currentTF == "60" ? "D" : currentTF == "240" ? "W" : currentTF == "D" ? "M" : ""

higherTimeframe = getHigherTimeframe()

// Buscar dados do timeframe superior
var float htf_ema55 = na
var float htf_ema233 = na
var float htf_close = na
var float htf_ema55_prev = na
var bool htf_trendUp = false
var bool htf_trendDown = false
var bool htf_trendNeutral = true
var string htf_trendText = "NEUTRO"

if higherTimeframe != ""
    // Buscar EMAs do timeframe superior
    htf_ema55 := request.security(syminfo.tickerid, higherTimeframe, ta.ema(close, 55), lookahead=barmerge.lookahead_off)
    htf_ema233 := request.security(syminfo.tickerid, higherTimeframe, ta.ema(close, 233), lookahead=barmerge.lookahead_off)
    htf_close := request.security(syminfo.tickerid, higherTimeframe, close, lookahead=barmerge.lookahead_off)
    htf_ema55_prev := request.security(syminfo.tickerid, higherTimeframe, ta.ema(close, 55)[1], lookahead=barmerge.lookahead_off)
    
    // Determinar tendência do fractal superior
    if na(htf_ema55) or na(htf_ema233) or na(htf_ema55_prev)
        htf_trendUp := false
        htf_trendDown := false
        htf_trendNeutral := true
        htf_trendText := "NEUTRO"
    else
        htf_trendUp := htf_ema55 > htf_ema233 and htf_ema55 > htf_ema55_prev and htf_close > htf_ema55
        htf_trendDown := htf_ema55 < htf_ema233 and htf_ema55 < htf_ema55_prev and htf_close < htf_ema55
        htf_trendNeutral := not htf_trendUp and not htf_trendDown
        htf_trendText := htf_trendUp ? "ALTA" : htf_trendDown ? "BAIXA" : "NEUTRO"

// ============================================================================
// CÁLCULO DO DIDI INDEX
// ============================================================================

media = ta.sma(close, mediaLength)
curta = ta.sma(close, curtaLength) / media
longa = ta.sma(close, longaLength) / media

didiCrossUp = ta.crossover(curta, longa)
didiCrossDown = ta.crossunder(curta, longa)

// CORREÇÃO: Detectar cruzamento recente (últimos setupWindow candles)
recentDidiCrossUp = ta.barssince(didiCrossUp) <= setupWindow
recentDidiCrossDown = ta.barssince(didiCrossDown) <= setupWindow

// Calcular distância do eixo no momento do cruzamento
var float crossDistance = na
if recentDidiCrossUp or recentDidiCrossDown
    crossDistance := math.abs(longa - 1.0) * 100

// Validar se cruzamento foi próximo ao eixo
nearAxis = not na(crossDistance) and crossDistance <= maxDistanceFromAxis

// Validar se ainda está em tendência
didiStillBullish = curta > longa
didiStillBearish = curta < longa

// ============================================================================
// CÁLCULO DO ADX/DMI
// ============================================================================

[diPlus, diMinus, adx] = ta.dmi(adxLength, adxSmoothing)

// ADX subindo com inclinação mínima
adxSlope = adx - adx[1]
adxRising = adxSlope >= adxMinSlope and adx >= adxMinValue

// Direção predominante
diPlusAbove = diPlus > diMinus
diMinusAbove = diMinus > diPlus

// ============================================================================
// CÁLCULO DAS BOLLINGER BANDS (LÓGICA REMI) - CORRIGIDO
// ============================================================================

bbBasis = ta.sma(close, bbLength)
bbDev = bbMult * ta.stdev(close, bbLength)
bbUpper = bbBasis + bbDev
bbLower = bbBasis - bbDev

// BBW do candle atual (gatilho)
bbwCurrent = bbUpper - bbLower

// Buscar menor e maior BBW nos últimos N candles
float minBBW = 999999.0
float maxBBW = 0.0

for i = 1 to bbExpansionLookback
    // CORREÇÃO: Calcular BBW histórico corretamente
    bbBasis_i = ta.sma(close, bbLength)[i]
    bbDev_i = bbMult * ta.stdev(close, bbLength)[i]
    bbUpper_i = bbBasis_i + bbDev_i
    bbLower_i = bbBasis_i - bbDev_i
    bbwTemp = bbUpper_i - bbLower_i
    
    if bbwTemp < minBBW
        minBBW := bbwTemp
    if bbwTemp > maxBBW
        maxBBW := bbwTemp

// Calcular BBW médio
bbwMedio = (minBBW + maxBBW) / 2

// Calcular razão de expansão (REMI)
remiRatio = bbwMedio > 0 ? bbwCurrent / bbwMedio : 0

// Validar expansão (mínimo e máximo)
bbExpanding = remiRatio >= bbExpansionRatio and remiRatio <= bbExpansionMaxRatio

// ============================================================================
// CÁLCULO DOS PIVOTS S/R
// ============================================================================

pivotHigh = ta.pivothigh(high, pivotLookback, pivotLookback)
var float resistance = na
if not na(pivotHigh)
    resistance := pivotHigh

pivotLow = ta.pivotlow(low, pivotLookback, pivotLookback)
var float support = na
if not na(pivotLow)
    support := pivotLow

// Breakout de resistência/suporte - CONFIGURÁVEL
bool breakoutResistance = false
bool breakoutSupport = false

if pivotBreakMethod == "Por Pavio (High/Low)"
    // Validação por HIGH/LOW (pavios) - preço está acima/abaixo
    breakoutResistance := not na(resistance) and high > resistance
    breakoutSupport := not na(support) and low < support
else
    // Validação por CLOSE (corpo do candle) - preço está acima/abaixo
    breakoutResistance := not na(resistance) and close > resistance
    breakoutSupport := not na(support) and close < support

// ============================================================================
// FILTROS DE CANDLE
// ============================================================================

candleBody = math.abs(close - open)
candleRange = high - low

// Filtro de pavio independente
upperWick = high - math.max(close, open)
lowerWick = math.min(close, open) - low

// Validação de pavio para LONG: pavio superior não pode ser maior que X% do corpo
wickOkLong = candleBody > 0 ? (upperWick / candleBody) <= maxWickPercent : false

// Validação de pavio para SHORT: pavio inferior não pode ser maior que X% do corpo
wickOkShort = candleBody > 0 ? (lowerWick / candleBody) <= maxWickPercent : false

// ============================================================================
// LÓGICA DO SETUP - CONSTRUÇÃO SEQUENCIAL
// ============================================================================

// Estados do setup
var int setupStateLong = 0  // 0=inativo, 1=construindo, 2=trigger formado, 3=confirmado
var int setupStateShort = 0

// Contadores de candles
var int setupStartBarLong = na
var int setupStartBarShort = na

// Trigger levels
var float triggerHighLong = na
var float triggerLowShort = na
var int triggerBarLong = na
var int triggerBarShort = na

// ============================================================================
// SETUP LONG
// ============================================================================

// Resetar se passou muito tempo
if setupStateLong == 1 and not na(setupStartBarLong) and (bar_index - setupStartBarLong) > setupWindow
    setupStateLong := 0
    setupStartBarLong := na

// Iniciar construção se Didi cruzou recentemente
if setupStateLong == 0 and recentDidiCrossUp and nearAxis
    setupStateLong := 1
    setupStartBarLong := bar_index

// Validar todas as condições dentro da janela
if setupStateLong == 1
    // Verificar se ainda está em tendência de alta
    allConditionsMet = didiStillBullish and adxRising and bbExpanding and breakoutResistance and diPlusAbove and wickOkLong
    
    if allConditionsMet
        setupStateLong := 2
        triggerHighLong := high
        triggerBarLong := bar_index

// Confirmação em tempo real (intrabar) no candle seguinte
if setupStateLong == 2 and bar_index >= triggerBarLong + 1
    if high > triggerHighLong
        setupStateLong := 3
    else if bar_index > triggerBarLong + 1
        // Expirou (passou 1 candle sem romper)
        setupStateLong := 0
        triggerHighLong := na
        triggerBarLong := na
        setupStartBarLong := na

// Resetar após confirmação (no próximo candle)
if setupStateLong == 3 and bar_index > triggerBarLong + 1
    setupStateLong := 0
    triggerHighLong := na
    triggerBarLong := na
    setupStartBarLong := na

// ============================================================================
// SETUP SHORT
// ============================================================================

// Resetar se passou muito tempo
if setupStateShort == 1 and not na(setupStartBarShort) and (bar_index - setupStartBarShort) > setupWindow
    setupStateShort := 0
    setupStartBarShort := na

// Iniciar construção se Didi cruzou recentemente
if setupStateShort == 0 and recentDidiCrossDown and nearAxis
    setupStateShort := 1
    setupStartBarShort := bar_index

// Validar todas as condições dentro da janela
if setupStateShort == 1
    // Verificar se ainda está em tendência de baixa
    allConditionsMet = didiStillBearish and adxRising and bbExpanding and breakoutSupport and diMinusAbove and wickOkShort
    
    if allConditionsMet
        setupStateShort := 2
        triggerLowShort := low
        triggerBarShort := bar_index

// Confirmação em tempo real (intrabar) no candle seguinte
if setupStateShort == 2 and bar_index >= triggerBarShort + 1
    if low < triggerLowShort
        setupStateShort := 3
    else if bar_index > triggerBarShort + 1
        // Expirou (passou 1 candle sem romper)
        setupStateShort := 0
        triggerLowShort := na
        triggerBarShort := na
        setupStartBarShort := na

// Resetar após confirmação (no próximo candle)
if setupStateShort == 3 and bar_index > triggerBarShort + 1
    setupStateShort := 0
    triggerLowShort := na
    triggerBarShort := na
    setupStartBarShort := na

// ============================================================================
// SINAIS
// ============================================================================

// CORREÇÃO v1.9: TRIGGER apenas no fechamento do candle
triggerLong = setupStateLong == 2 and bar_index == triggerBarLong and barstate.isconfirmed
triggerShort = setupStateShort == 2 and bar_index == triggerBarShort and barstate.isconfirmed

confirmedLong = setupStateLong == 3
confirmedShort = setupStateShort == 3

// ============================================================================
// GESTÃO DE RISCO
// ============================================================================

var float entryLong = na
var float stopLossLong = na
var float target1Long = na
var float target2Long = na
var float riskLong = na
var float riskPercentLong = na
var float trailingLong = na

if confirmedLong
    // Entry: HIGH do candle gatilho
    entryLong := triggerHighLong
    
    // SL: Baseado no método escolhido
    tickSize = syminfo.mintick
    
    if slMethod == "3 Candles Anteriores"
        // SL: 1 tick abaixo do menor LOW dos 3 candles anteriores
        lowestLow = math.min(low[1], low[2], low[3])
        stopLossLong := lowestLow - tickSize
    else
        // SL: 1 tick abaixo do último suporte (pivot)
        stopLossLong := support - tickSize
    
    // Gestão de risco
    riskLong := entryLong - stopLossLong
    riskPercentLong := (riskLong / entryLong) * 100
    target1Long := entryLong + (riskLong * 1.0)
    target2Long := entryLong + (riskLong * 2.0)
    trailingLong := riskLong * 0.5

var float entryShort = na
var float stopLossShort = na
var float target1Short = na
var float target2Short = na
var float riskShort = na
var float riskPercentShort = na
var float trailingShort = na

if confirmedShort
    // Entry: LOW do candle gatilho
    entryShort := triggerLowShort
    
    // SL: Baseado no método escolhido
    tickSize = syminfo.mintick
    
    if slMethod == "3 Candles Anteriores"
        // SL: 1 tick acima do maior HIGH dos 3 candles anteriores
        highestHigh = math.max(high[1], high[2], high[3])
        stopLossShort := highestHigh + tickSize
    else
        // SL: 1 tick acima da última resistência (pivot)
        stopLossShort := resistance + tickSize
    
    // Gestão de risco
    riskShort := stopLossShort - entryShort
    riskPercentShort := (riskShort / entryShort) * 100
    target1Short := entryShort - (riskShort * 1.0)
    target2Short := entryShort - (riskShort * 2.0)
    trailingShort := riskShort * 0.5

// ============================================================================
// CLASSIFICAÇÃO DO SETUP (MTF) - NOVO v2.0
// ============================================================================

var string setupQuality = "CAUTELA"

if confirmedLong or triggerLong
    if htf_trendUp
        setupQuality := "PREMIUM"
    else if htf_trendDown
        setupQuality := "CONTRA"
    else
        setupQuality := "CAUTELA"

if confirmedShort or triggerShort
    if htf_trendDown
        setupQuality := "PREMIUM"
    else if htf_trendUp
        setupQuality := "CONTRA"
    else
        setupQuality := "CAUTELA"

// ============================================================================
// VISUALIZAÇÃO
// ============================================================================

// TRIGGER - Labels
if triggerLong
    label.new(bar_index, low, "DNP LONG", color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_up, size=size.small)

if triggerShort
    label.new(bar_index, high, "DNP SHORT", color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.small)

// CONFIRMED - Setinhas
plotshape(confirmedLong, title="CONFIRMED LONG", location=location.belowbar, color=color.new(color.orange, 0), style=shape.triangleup, size=size.small)
plotshape(confirmedShort, title="CONFIRMED SHORT", location=location.abovebar, color=color.new(color.orange, 0), style=shape.triangledown, size=size.small)

// ============================================================================
// DASHBOARD
// ============================================================================

if showDashboard
    // Criar tabela uma vez e limpar em cada barra para atualização dinâmica
    var table dashboard = table.new(position.top_right, 2, 16, border_width=1)
    
    // Limpar tabela para repopular com valores da barra atual
    table.clear(dashboard, 0, 0, 1, 15)
    
    // Cabeçalho
    table.cell(dashboard, 0, 0, "CryptoMind IA", text_color=color.orange, text_size=size.normal, bgcolor=color.new(color.black, 10))
    table.cell(dashboard, 1, 0, "DNP v2.0", text_color=color.yellow, text_size=size.normal, bgcolor=color.new(color.black, 10))
    
    // MTF - NOVO v2.0
    table.cell(dashboard, 0, 1, "MTF Tendência:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    mtfColor = htf_trendUp ? color.green : htf_trendDown ? color.red : color.gray
    table.cell(dashboard, 1, 1, htf_trendText + " (" + higherTimeframe + ")", text_color=mtfColor, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    // Parâmetros Didi
    table.cell(dashboard, 0, 2, "Didi Dist. Eixo:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    table.cell(dashboard, 1, 2, str.tostring(maxDistanceFromAxis, '#.##') + "%", text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    table.cell(dashboard, 0, 3, "Didi Cruzamento:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    didiStatus = (recentDidiCrossUp or recentDidiCrossDown) and nearAxis
    table.cell(dashboard, 1, 3, didiStatus ? "✓ ATIVO" : "✗ INATIVO", text_color=didiStatus ? color.green : color.red, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    // Parâmetros ADX
    table.cell(dashboard, 0, 4, "ADX Atual:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    table.cell(dashboard, 1, 4, str.tostring(adx, '#.##'), text_color=adx >= adxMinValue ? color.green : color.red, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    table.cell(dashboard, 0, 5, "ADX Inclinação:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    table.cell(dashboard, 1, 5, str.tostring(adxSlope, '#.##'), text_color=adxSlope >= adxMinSlope ? color.green : color.red, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    table.cell(dashboard, 0, 6, "ADX Rising:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    table.cell(dashboard, 1, 6, adxRising ? "✓ ATIVO" : "✗ INATIVO", text_color=adxRising ? color.green : color.red, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    // Parâmetros Bollinger
    table.cell(dashboard, 0, 7, "REMI Atual:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    // Cor: verde se dentro do range (mín-máx), vermelho se fora
    remiColor = (remiRatio >= bbExpansionRatio and remiRatio <= bbExpansionMaxRatio) ? color.green : color.red
    table.cell(dashboard, 1, 7, str.tostring(remiRatio, '#.##'), text_color=remiColor, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    // Pivots
    table.cell(dashboard, 0, 8, "Resistência:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    table.cell(dashboard, 1, 8, not na(resistance) ? str.tostring(resistance, format.mintick) : "N/A", text_color=color.red, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    table.cell(dashboard, 0, 9, "Suporte:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    table.cell(dashboard, 1, 9, not na(support) ? str.tostring(support, format.mintick) : "N/A", text_color=color.green, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    table.cell(dashboard, 0, 10, "Pivot Breakout:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    pivotBreak = breakoutResistance or breakoutSupport
    table.cell(dashboard, 1, 10, pivotBreak ? "✓ ATIVO" : "✗ INATIVO", text_color=pivotBreak ? color.green : color.red, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    // Método Pivot
    table.cell(dashboard, 0, 11, "Método Pivot:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    pivotMethodShort = pivotBreakMethod == "Por Pavio (High/Low)" ? "PAVIO" : "CLOSE"
    table.cell(dashboard, 1, 11, pivotMethodShort, text_color=color.yellow, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    // Pavio
    table.cell(dashboard, 0, 12, "Pavio OK:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    wickOk = wickOkLong or wickOkShort
    table.cell(dashboard, 1, 12, wickOk ? "✓ ATIVO" : "✗ INATIVO", text_color=wickOk ? color.green : color.red, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    // Setup State
    table.cell(dashboard, 0, 13, "Setup State:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    setupState = setupStateLong > 0 ? setupStateLong : setupStateShort
    stateText = setupState == 0 ? "INATIVO" : setupState == 1 ? "CONSTRUINDO" : setupState == 2 ? "TRIGGER" : "CONFIRMADO"
    stateColor = setupState == 0 ? color.gray : setupState == 1 ? color.yellow : setupState == 2 ? color.orange : color.green
    table.cell(dashboard, 1, 13, stateText, text_color=stateColor, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    // Trigger Level
    table.cell(dashboard, 0, 14, "Trigger Level:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    triggerLevel = not na(triggerHighLong) ? str.tostring(triggerHighLong, format.mintick) : not na(triggerLowShort) ? str.tostring(triggerLowShort, format.mintick) : "N/A"
    table.cell(dashboard, 1, 14, triggerLevel, text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 10))
    
    // Direção
    table.cell(dashboard, 0, 15, "Direção:", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.black, 10))
    direction = diPlusAbove ? "LONG (DI+)" : diMinusAbove ? "SHORT (DI-)" : "NEUTRO"
    dirColor = diPlusAbove ? color.green : diMinusAbove ? color.red : color.gray
    table.cell(dashboard, 1, 15, direction, text_color=dirColor, text_size=size.small, bgcolor=color.new(color.black, 10))

// ============================================================================
// ALERTAS - COM MTF v2.0
// ============================================================================

if triggerLong
    alertJson = '{"symbol":"' + syminfo.ticker + '","action":"TRIGGER","direction":"LONG","setup":"DNP","timeframe":"' + timeframe.period + '","price":"' + str.tostring(close, format.mintick) + '","triggerHigh":"' + str.tostring(triggerHighLong, format.mintick) + '","adx":"' + str.tostring(adx, '#.##') + '","remi":"' + str.tostring(remiRatio, '#.##') + '","setupQuality":"' + setupQuality + '","htfTrend":"' + htf_trendText + '","htfTimeframe":"' + higherTimeframe + '"}'
    alert(alertJson, alert.freq_once_per_bar)

if triggerShort
    alertJson = '{"symbol":"' + syminfo.ticker + '","action":"TRIGGER","direction":"SHORT","setup":"DNP","timeframe":"' + timeframe.period + '","price":"' + str.tostring(close, format.mintick) + '","triggerLow":"' + str.tostring(triggerLowShort, format.mintick) + '","adx":"' + str.tostring(adx, '#.##') + '","remi":"' + str.tostring(remiRatio, '#.##') + '","setupQuality":"' + setupQuality + '","htfTrend":"' + htf_trendText + '","htfTimeframe":"' + higherTimeframe + '"}'
    alert(alertJson, alert.freq_once_per_bar)

if confirmedLong
    alertJson = '{"symbol":"' + syminfo.ticker + '","action":"CONFIRMED","direction":"LONG","setup":"DNP","timeframe":"' + timeframe.period + '","price":"' + str.tostring(close, format.mintick) + '","entry":"' + str.tostring(entryLong, format.mintick) + '","stopLoss":"' + str.tostring(stopLossLong, format.mintick) + '","risk":"' + str.tostring(riskLong, format.mintick) + '","riskPercent":"' + str.tostring(riskPercentLong, '#.##') + '","target1":"' + str.tostring(target1Long, format.mintick) + '","target2":"' + str.tostring(target2Long, format.mintick) + '","trailingDistance":"' + str.tostring(trailingLong, format.mintick) + '","triggerHigh":"' + str.tostring(triggerHighLong, format.mintick) + '","adx":"' + str.tostring(adx, '#.##') + '","remi":"' + str.tostring(remiRatio, '#.##') + '","setupQuality":"' + setupQuality + '","htfTrend":"' + htf_trendText + '","htfTimeframe":"' + higherTimeframe + '"}'
    alert(alertJson, alert.freq_once_per_bar)

if confirmedShort
    alertJson = '{"symbol":"' + syminfo.ticker + '","action":"CONFIRMED","direction":"SHORT","setup":"DNP","timeframe":"' + timeframe.period + '","price":"' + str.tostring(close, format.mintick) + '","entry":"' + str.tostring(entryShort, format.mintick) + '","stopLoss":"' + str.tostring(stopLossShort, format.mintick) + '","risk":"' + str.tostring(riskShort, format.mintick) + '","riskPercent":"' + str.tostring(riskPercentShort, '#.##') + '","target1":"' + str.tostring(target1Short, format.mintick) + '","target2":"' + str.tostring(target2Short, format.mintick) + '","trailingDistance":"' + str.tostring(trailingShort, format.mintick) + '","triggerLow":"' + str.tostring(triggerLowShort, format.mintick) + '","adx":"' + str.tostring(adx, '#.##') + '","remi":"' + str.tostring(remiRatio, '#.##') + '","setupQuality":"' + setupQuality + '","htfTrend":"' + htf_trendText + '","htfTimeframe":"' + higherTimeframe + '"}'
    alert(alertJson, alert.freq_once_per_bar)
