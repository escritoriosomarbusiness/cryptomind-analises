//@version=6
indicator("PES v2.0 (Tier 2) - Price Expansion System", shorttitle="PES v2.0", overlay=true)

// =============================================================================
//                             INPUTS
// =============================================================================
entry_len = input.int(20, "Período Canal de Entrada", minval=1, group="Canais")
exit_len = input.int(10, "Período Canal de Saída", minval=1, group="Canais")
show_channels = input.bool(true, "Mostrar Canais no Gráfico", group="Visualização")
show_dashboard = input.bool(true, "Mostrar Dashboard", group="Visualização")

// =============================================================================
//                    ANÁLISE MULTI-TIMEFRAME (MTF)
// =============================================================================

// Função para determinar o timeframe superior (fractal superior)
getHigherTimeframe() =>
    currentTF = timeframe.period
    currentTF == "1" ? "15" : 
     currentTF == "5" ? "60" : 
     currentTF == "15" ? "240" : 
     currentTF == "60" ? "D" : 
     currentTF == "240" ? "W" : 
     currentTF == "D" ? "M" : ""

higherTimeframe = getHigherTimeframe()

// Buscar dados do timeframe superior
var float htf_ema55 = na
var float htf_ema233 = na
var float htf_close = na
var float htf_ema55_prev = na
var bool htf_trendUp = false
var bool htf_trendDown = false
var bool htf_trendNeutral = true
var string htf_trendText = "NEUTRO"

if higherTimeframe != ""
    // Buscar EMAs do timeframe superior
    htf_ema55 := request.security(syminfo.tickerid, higherTimeframe, ta.ema(close, 55), lookahead=barmerge.lookahead_off)
    htf_ema233 := request.security(syminfo.tickerid, higherTimeframe, ta.ema(close, 233), lookahead=barmerge.lookahead_off)
    htf_close := request.security(syminfo.tickerid, higherTimeframe, close, lookahead=barmerge.lookahead_off)
    htf_ema55_prev := request.security(syminfo.tickerid, higherTimeframe, ta.ema(close, 55)[1], lookahead=barmerge.lookahead_off)
    
    // Determinar tendência do fractal superior
    if na(htf_ema55) or na(htf_ema233) or na(htf_ema55_prev)
        htf_trendUp := false
        htf_trendDown := false
        htf_trendNeutral := true
        htf_trendText := "NEUTRO"
    else
        htf_trendUp := htf_ema55 > htf_ema233 and htf_ema55 > htf_ema55_prev and htf_close > htf_ema55
        htf_trendDown := htf_ema55 < htf_ema233 and htf_ema55 < htf_ema55_prev and htf_close < htf_ema55
        htf_trendNeutral := not htf_trendUp and not htf_trendDown
        htf_trendText := htf_trendUp ? "ALTA" : htf_trendDown ? "BAIXA" : "NEUTRO"

// =============================================================================
//                             CÁLCULO DOS CANAIS
// =============================================================================
entry_high = ta.highest(high, entry_len)[1]
entry_low = ta.lowest(low, entry_len)[1]
exit_high = ta.highest(high, exit_len)[1]
exit_low = ta.lowest(low, exit_len)[1]

// Plotar canais
plot(show_channels ? entry_high : na, "Entrada Long", color=color.new(color.green, 0))
plot(show_channels ? entry_low : na, "Entrada Short", color=color.new(color.red, 0))
plot(show_channels ? exit_low : na, "Saída Long", color=color.new(color.maroon, 20))
plot(show_channels ? exit_high : na, "Saída Short", color=color.new(color.teal, 20))

// =============================================================================
//                       FILTRO DE FORÇA DO CANDLE
// =============================================================================
candle_range = high - low
upper_third = high - (candle_range / 3)
lower_third = low + (candle_range / 3)

// Validação: candle deve fechar no terço final
candle_strong_long = close >= upper_third
candle_strong_short = close <= lower_third

// =============================================================================
//                             GESTÃO DE ESTADO
// =============================================================================
var bool in_long_position = false
var bool in_short_position = false
var string signal_id = na
var string signal_quality = na

// Função para gerar um ID único para o sinal
generate_signal_id() =>
    str.tostring(syminfo.ticker) + "_" + timeframe.period + "_" + str.tostring(time)

// Função para classificar qualidade do sinal
classify_signal_quality(is_long) =>
    if is_long
        htf_trendUp ? "PREMIUM" : htf_trendDown ? "CONTRA" : "CAUTELA"
    else
        htf_trendDown ? "PREMIUM" : htf_trendUp ? "CONTRA" : "CAUTELA"

// =============================================================================
//                             LÓGICA DE SINAIS
// =============================================================================

// --- CONDIÇÕES DE ENTRADA COM FILTROS ---
long_entry_base = not in_long_position and not in_short_position and close > entry_high
long_entry_condition = long_entry_base and candle_strong_long

short_entry_base = not in_short_position and not in_long_position and close < entry_low
short_entry_condition = short_entry_base and candle_strong_short

// --- CONDIÇÕES DE SAÍDA ---
long_exit_condition = in_long_position and close < exit_low
short_exit_condition = in_short_position and close > exit_high

// =============================================================================
//                             ALERTAS E WEBHOOKS
// =============================================================================

// --- LÓGICA DE ENTRADA LONG ---
if long_entry_condition
    in_long_position := true
    signal_id := generate_signal_id()
    signal_quality := classify_signal_quality(true)
    
    alert_message_long_entry = 
     "{\"action\": \"PES_SIGNAL\", " + 
     "\"signal_id\": \"" + signal_id + "\", " + 
     "\"symbol\": \"" + syminfo.ticker + "\", " + 
     "\"timeframe\": \"" + timeframe.period + "\", " + 
     "\"type\": \"LONG_ENTRY\", " + 
     "\"price\": " + str.tostring(close) + ", " + 
     "\"quality\": \"" + signal_quality + "\", " + 
     "\"mtf_trend\": \"" + htf_trendText + "\", " + 
     "\"entry_channel\": " + str.tostring(entry_high) + ", " + 
     "\"exit_channel\": " + str.tostring(exit_low) + "}"
    alert(alert_message_long_entry, alert.freq_once_per_bar_close)

// --- LÓGICA DE SAÍDA LONG ---
if long_exit_condition
    in_long_position := false
    alert_message_long_exit = 
     "{\"action\": \"PES_SIGNAL\", " + 
     "\"signal_id\": \"" + signal_id + "\", " + 
     "\"symbol\": \"" + syminfo.ticker + "\", " + 
     "\"timeframe\": \"" + timeframe.period + "\", " + 
     "\"type\": \"LONG_EXIT\", " + 
     "\"price\": " + str.tostring(close) + "}"
    alert(alert_message_long_exit, alert.freq_once_per_bar_close)
    signal_id := na
    signal_quality := na

// --- LÓGICA DE ENTRADA SHORT ---
if short_entry_condition
    in_short_position := true
    signal_id := generate_signal_id()
    signal_quality := classify_signal_quality(false)
    
    alert_message_short_entry = 
     "{\"action\": \"PES_SIGNAL\", " + 
     "\"signal_id\": \"" + signal_id + "\", " + 
     "\"symbol\": \"" + syminfo.ticker + "\", " + 
     "\"timeframe\": \"" + timeframe.period + "\", " + 
     "\"type\": \"SHORT_ENTRY\", " + 
     "\"price\": " + str.tostring(close) + ", " + 
     "\"quality\": \"" + signal_quality + "\", " + 
     "\"mtf_trend\": \"" + htf_trendText + "\", " + 
     "\"entry_channel\": " + str.tostring(entry_low) + ", " + 
     "\"exit_channel\": " + str.tostring(exit_high) + "}"
    alert(alert_message_short_entry, alert.freq_once_per_bar_close)

// --- LÓGICA DE SAÍDA SHORT ---
if short_exit_condition
    in_short_position := false
    alert_message_short_exit = 
     "{\"action\": \"PES_SIGNAL\", " + 
     "\"signal_id\": \"" + signal_id + "\", " + 
     "\"symbol\": \"" + syminfo.ticker + "\", " + 
     "\"timeframe\": \"" + timeframe.period + "\", " + 
     "\"type\": \"SHORT_EXIT\", " + 
     "\"price\": " + str.tostring(close) + "}"
    alert(alert_message_short_exit, alert.freq_once_per_bar_close)
    signal_id := na
    signal_quality := na

// =============================================================================
//                             VISUALIZAÇÃO
// =============================================================================

// Cores das labels baseadas na qualidade
label_color_long = signal_quality == "PREMIUM" ? color.new(color.green, 0) : 
                   signal_quality == "CAUTELA" ? color.new(color.yellow, 0) : 
                   color.new(color.orange, 0)

label_color_short = signal_quality == "PREMIUM" ? color.new(color.red, 0) : 
                    signal_quality == "CAUTELA" ? color.new(color.yellow, 0) : 
                    color.new(color.orange, 0)

// Plotar sinais com cores baseadas na qualidade
plotshape(long_entry_condition, title="Entrada Long", location=location.belowbar, 
          color=label_color_long, style=shape.triangleup, size=size.small)
plotshape(short_entry_condition, title="Entrada Short", location=location.abovebar, 
          color=label_color_short, style=shape.triangledown, size=size.small)
plotshape(long_exit_condition, title="Saída Long", location=location.belowbar, 
          color=color.new(color.maroon, 0), style=shape.cross, size=size.small)
plotshape(short_exit_condition, title="Saída Short", location=location.abovebar, 
          color=color.new(color.teal, 0), style=shape.cross, size=size.small)

// Fundo colorido para indicar posição
bg_color = in_long_position ? color.new(color.green, 90) : 
           in_short_position ? color.new(color.red, 90) : na
bgcolor(bg_color)

// =============================================================================
//                             DASHBOARD
// =============================================================================
if show_dashboard
    var table dashboard = table.new(position.top_right, 2, 5, border_width=1)
    
    table.clear(dashboard, 0, 0, 1, 4)
    
    // Cabeçalho
    table.cell(dashboard, 0, 0, "PES v2.0", text_color=color.orange, text_size=size.normal, 
               bgcolor=color.new(color.black, 10))
    table.cell(dashboard, 1, 0, syminfo.ticker, text_color=color.yellow, text_size=size.normal, 
               bgcolor=color.new(color.black, 10))
    
    // MTF Tendência
    table.cell(dashboard, 0, 1, "MTF (" + higherTimeframe + "):", text_color=color.gray, 
               text_size=size.small, bgcolor=color.new(color.black, 10))
    mtfColor = htf_trendUp ? color.green : htf_trendDown ? color.red : color.gray
    table.cell(dashboard, 1, 1, htf_trendText, text_color=mtfColor, text_size=size.small, 
               bgcolor=color.new(color.black, 10))
    
    // Posição Atual
    table.cell(dashboard, 0, 2, "Posição:", text_color=color.gray, text_size=size.small, 
               bgcolor=color.new(color.black, 10))
    positionText = in_long_position ? "LONG" : in_short_position ? "SHORT" : "AGUARDANDO"
    positionColor = in_long_position ? color.green : in_short_position ? color.red : color.gray
    table.cell(dashboard, 1, 2, positionText, text_color=positionColor, text_size=size.small, 
               bgcolor=color.new(color.black, 10))
    
    // Qualidade do Sinal
    if not na(signal_quality)
        table.cell(dashboard, 0, 3, "Qualidade:", text_color=color.gray, text_size=size.small, 
                   bgcolor=color.new(color.black, 10))
        qualityColor = signal_quality == "PREMIUM" ? color.green : 
                       signal_quality == "CAUTELA" ? color.yellow : color.orange
        table.cell(dashboard, 1, 3, signal_quality, text_color=qualityColor, text_size=size.small, 
                   bgcolor=color.new(color.black, 10))
    
    // Timeframe
    table.cell(dashboard, 0, 4, "Timeframe:", text_color=color.gray, text_size=size.small, 
               bgcolor=color.new(color.black, 10))
    table.cell(dashboard, 1, 4, timeframe.period, text_color=color.white, text_size=size.small, 
               bgcolor=color.new(color.black, 10))
