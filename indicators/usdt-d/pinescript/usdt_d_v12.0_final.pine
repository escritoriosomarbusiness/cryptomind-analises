//@version=6
// ============================================
// USDT.D MONITOR v12.0 - LUXALGO EDITION [PROFESSIONAL]
// ============================================
// Autor: CryptoMind IA
// Vers√£o: 12.0 (Corre√ß√£o Profissional)
// Data: 19/01/2026
//
// CHANGELOG v12.0:
// ‚úÖ Alertas disparam apenas UMA vez no momento exato do evento
// ‚úÖ Detec√ß√£o de reteste em n√≠veis rompidos (invers√£o autom√°tica)
// ‚úÖ Sistema de rastreamento de n√≠veis quebrados
// ‚úÖ L√≥gica profissional com crossover/crossunder
// ‚úÖ 100% compat√≠vel com v11.0 (mesma visualiza√ß√£o)
//
// Baseado no algoritmo LuxAlgo de Pivot Points & Missed Reversals
// Detecta automaticamente suporte/resist√™ncia e revers√µes perdidas
// Sistema de alertas otimizado para webhook n8n ‚Üí Telegram
// ============================================

indicator("USDT.D Monitor v12.0 [LuxAlgo Edition]", overlay=true, max_labels_count=500, max_lines_count=500, max_bars_back=500)

// ============================================
// INPUTS
// ============================================
length = input.int(50, 'Pivot Length', minval=1, tooltip='Tamanho da janela para detec√ß√£o de pivots. Valores maiores = revers√µes mais significativas')

show_reg = input.bool(true, 'Mostrar Pivots Regulares', inline='inline1')
reg_ph_css = input.color(#ef5350, 'Resist√™ncia', inline='inline1')
reg_pl_css = input.color(#26a69a, 'Suporte', inline='inline1')

show_miss = input.bool(true, 'Mostrar Revers√µes Perdidas', inline='inline2')
miss_ph_css = input.color(#ef5350, 'Resist√™ncia', inline='inline2')
miss_pl_css = input.color(#26a69a, 'Suporte', inline='inline2')

label_css = input.color(color.white, 'Cor do Texto')

// Configura√ß√µes de alerta
touchTolerance = input.float(0.02, 'Toler√¢ncia de Toque (%)', minval=0.01, step=0.01, tooltip='Dist√¢ncia percentual para considerar toque no n√≠vel')

// ============================================
// VARI√ÅVEIS PRINCIPAIS
// ============================================
var line zigzag = na
var line ghost_level = na
var float max = 0.
var float min = 0.
var int max_x1 = 0
var int min_x1 = 0
var float follow_max = 0.
var int follow_max_x1 = 0
var float follow_min = 0.
var int follow_min_x1 = 0
var int os = 0
var float py1 = 0.
var int px1 = 0

// Vari√°veis para alertas
var float lastRegularHigh = na
var float lastRegularLow = na
var float lastMissedHigh = na
var float lastMissedLow = na

// ============================================
// NOVO v12.0: RASTREAMENTO DE N√çVEIS ROMPIDOS
// ============================================
var float brokenResistance = na  // Resist√™ncia rompida (agora √© suporte)
var float brokenSupport = na     // Suporte rompido (agora √© resist√™ncia)
var int lastBreakBar = na        // Barra do √∫ltimo rompimento

// ============================================
// DETEC√á√ÉO DE PIVOTS
// ============================================
n = bar_index
ph = ta.pivothigh(length, length)
pl = ta.pivotlow(length, length)

// Rastreamento cont√≠nuo de m√°ximos e m√≠nimos
max := math.max(high[length], max)
min := math.min(low[length], min)
follow_max := math.max(high[length], follow_max)
follow_min := math.min(low[length], follow_min)

// Atualizar posi√ß√µes dos extremos
if max > max[1]
    max_x1 := n - length
    follow_min := low[length]

if min < min[1]
    min_x1 := n - length    
    follow_max := high[length]

if follow_min < follow_min[1]
    follow_min_x1 := n - length

if follow_max > follow_max[1]
    follow_max_x1 := n - length

// ============================================
// ESTENDER N√çVEIS FANTASMA
// ============================================
line.set_x2(ghost_level[1], n)

// ============================================
// PROCESSAR PIVOT HIGH
// ============================================
if not na(ph)
    if show_miss
        if os[1] == 1
            // Dois pivot highs consecutivos ‚Üí Missed reversal LOW
            label.new(min_x1, min, 'üëª', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(min, '#.####'))
            
            zigzag := line.new(px1, py1, min_x1, min, color=miss_ph_css, style=line.style_dashed)
            px1 := min_x1
            py1 := min
            
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_pl_css, 50), width=2)
            
            // Registrar missed reversal para alertas
            lastMissedLow := min
            
        else if ph < max
            // Pivot high menor que m√°ximo anterior ‚Üí Missed reversals
            label.new(max_x1, max, 'üëª', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(max, '#.####'))
            label.new(follow_min_x1, follow_min, 'üëª', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(min, '#.####'))
            
            zigzag := line.new(px1, py1, max_x1, max, color=miss_pl_css, style=line.style_dashed)
            px1 := max_x1
            py1 := max
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_ph_css, 50), width=2)
            
            zigzag := line.new(px1, py1, follow_min_x1, follow_min, color=miss_ph_css, style=line.style_dashed)
            px1 := follow_min_x1
            py1 := follow_min
            line.set_x2(ghost_level, px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_pl_css, 50), width=2)
            
            // Registrar missed reversals para alertas
            lastMissedHigh := max
            lastMissedLow := follow_min

    if show_reg
        label.new(n - length, ph, '‚ñº', textcolor=label_css, color=reg_ph_css, style=label.style_label_down, size=size.small,
          tooltip=str.tostring(ph, '#.####'))
        zigzag := line.new(px1, py1, n - length, ph, color=miss_pl_css, style=ph < max or os[1] == 1 ? line.style_dashed : line.style_solid)
    
    // Registrar pivot regular para alertas
    lastRegularHigh := ph
    
    py1 := ph
    px1 := n - length
    os := 1
    max := ph
    min := ph

// ============================================
// PROCESSAR PIVOT LOW
// ============================================
if not na(pl)
    if show_miss  
        if os[1] == 0
            // Dois pivot lows consecutivos ‚Üí Missed reversal HIGH
            label.new(max_x1, max, 'üëª', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(max, '#.####'))
            
            zigzag := line.new(px1, py1, max_x1, max, color=miss_pl_css, style=line.style_dashed)
            px1 := max_x1
            py1 := max
            
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_ph_css, 50), width=2)
            
            // Registrar missed reversal para alertas
            lastMissedHigh := max
            
        else if pl > min
            // Pivot low maior que m√≠nimo anterior ‚Üí Missed reversals
            label.new(follow_max_x1, follow_max, 'üëª', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(max, '#.####'))
            label.new(min_x1, min, 'üëª', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(min, '#.####'))
            
            zigzag := line.new(px1, py1, min_x1, min, color=miss_ph_css, style=line.style_dashed)
            px1 := min_x1
            py1 := min
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_pl_css, 50), width=2)
            
            zigzag := line.new(px1, py1, follow_max_x1, follow_max, color=miss_pl_css, style=line.style_dashed)
            px1 := follow_max_x1
            py1 := follow_max
            line.set_x2(ghost_level, px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_ph_css, 50), width=2)
            
            // Registrar missed reversals para alertas
            lastMissedHigh := follow_max
            lastMissedLow := min

    if show_reg
        label.new(n - length, pl, '‚ñ≤', textcolor=label_css, color=reg_pl_css, style=label.style_label_up, size=size.small,
          tooltip=str.tostring(pl, '#.####'))
        zigzag := line.new(px1, py1, n - length, pl, color=miss_ph_css, style=pl > min or os[1] == 0 ? line.style_dashed : line.style_solid)
    
    // Registrar pivot regular para alertas
    lastRegularLow := pl
    
    py1 := pl
    px1 := n - length
    os := 0
    max := pl
    min := pl

// ============================================
// ESTIMATIVA EM TEMPO REAL
// ============================================
var label lbl = na
if barstate.islast
    x = 0
    y = 0.
    
    prices = array.new<float>(0)
    prices_x = array.new<int>(0)
    
    for i = 0 to n - px1 - 1
        array.push(prices, os == 1 ? low[i] : high[i])
        array.push(prices_x, n - i)
    
    label.delete(lbl[1])
    
    if os == 1
        y := array.min(prices)
        x := array.get(prices_x, array.indexof(prices, y))
        
        if show_miss
            lbl := label.new(x, y, 'üëª', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(y, '#.####'))
    else
        y := array.max(prices)
        x := array.get(prices_x, array.indexof(prices, y))
        
        if show_miss
            lbl := label.new(x, y, 'üëª', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(y, '#.####'))
            
    if show_miss
        line.delete(line.new(px1, py1, x, y, color=os == 1 ? miss_ph_css : miss_pl_css, style=line.style_dashed)[1])
    
    line.delete(line.new(x, y, n, y, color=color.new(os == 1 ? miss_ph_css : miss_pl_css, 50), width=2)[1])

// ============================================
// SISTEMA DE ALERTAS v12.0 (PROFISSIONAL)
// ============================================

// Calcular toler√¢ncia em valor absoluto
tolerance = close * touchTolerance / 100

// ============================================
// DETEC√á√ÉO DE EVENTOS √öNICOS (NOVO v12.0)
// ============================================

// 1. DETEC√á√ÉO DE ROMPIMENTOS (usando crossover/crossunder para disparo √∫nico)
bool breakRegularHigh = false
bool breakRegularLow = false

if not na(lastRegularHigh)
    // Rompimento de resist√™ncia: crossover acima do n√≠vel + toler√¢ncia
    breakRegularHigh := ta.crossover(close, lastRegularHigh + tolerance)
    
if not na(lastRegularLow)
    // Rompimento de suporte: crossunder abaixo do n√≠vel - toler√¢ncia
    breakRegularLow := ta.crossunder(close, lastRegularLow - tolerance)

// Atualizar n√≠veis rompidos quando ocorre BREAK
if breakRegularHigh
    brokenResistance := lastRegularHigh  // Resist√™ncia rompida vira suporte
    brokenSupport := na                   // Limpar suporte rompido anterior
    lastBreakBar := bar_index

if breakRegularLow
    brokenSupport := lastRegularLow      // Suporte rompido vira resist√™ncia
    brokenResistance := na                // Limpar resist√™ncia rompida anterior
    lastBreakBar := bar_index

// 2. DETEC√á√ÉO DE TOQUES (somente se n√£o houve BREAK nesta barra)
bool touchRegularHigh = false
bool touchRegularLow = false
bool touchMissedHigh = false
bool touchMissedLow = false

// Toques em n√≠veis ATIVOS (n√£o rompidos)
if not breakRegularHigh and not breakRegularLow
    // Touch em pivots regulares (somente se n√£o foram rompidos)
    if not na(lastRegularHigh) and na(brokenResistance)
        // Toque em resist√™ncia: pre√ßo entra na zona de toler√¢ncia vindo de baixo
        touchRegularHigh := close >= lastRegularHigh - tolerance and close <= lastRegularHigh + tolerance and close[1] < lastRegularHigh - tolerance
    
    if not na(lastRegularLow) and na(brokenSupport)
        // Toque em suporte: pre√ßo entra na zona de toler√¢ncia vindo de cima
        touchRegularLow := close >= lastRegularLow - tolerance and close <= lastRegularLow + tolerance and close[1] > lastRegularLow + tolerance
    
    // Touch em missed reversals
    if not na(lastMissedHigh)
        touchMissedHigh := close >= lastMissedHigh - tolerance and close <= lastMissedHigh + tolerance and close[1] < lastMissedHigh - tolerance
    
    if not na(lastMissedLow)
        touchMissedLow := close >= lastMissedLow - tolerance and close <= lastMissedLow + tolerance and close[1] > lastMissedLow + tolerance

// 3. DETEC√á√ÉO DE RETESTE (NOVO v12.0)
bool retestBrokenResistance = false
bool retestBrokenSupport = false

// Reteste de resist√™ncia rompida (agora √© suporte)
if not na(brokenResistance) and not na(lastBreakBar) and (bar_index - lastBreakBar) > 1
    // Pre√ßo volta e toca o n√≠vel que era resist√™ncia (agora suporte)
    retestBrokenResistance := close >= brokenResistance - tolerance and close <= brokenResistance + tolerance and close[1] < brokenResistance - tolerance

// Reteste de suporte rompido (agora √© resist√™ncia)
if not na(brokenSupport) and not na(lastBreakBar) and (bar_index - lastBreakBar) > 1
    // Pre√ßo volta e toca o n√≠vel que era suporte (agora resist√™ncia)
    retestBrokenSupport := close >= brokenSupport - tolerance and close <= brokenSupport + tolerance and close[1] > brokenSupport + tolerance

// ============================================
// CONSTRU√á√ÉO DO ALERTA
// ============================================

string eventType = na
string pivotType = na
string direction = na
float level = na

// Prioridade: BREAK > RETESTE > TOUCH

if breakRegularHigh
    eventType := "BREAK"
    pivotType := "REGULAR"
    direction := "HIGH"
    level := lastRegularHigh
else if breakRegularLow
    eventType := "BREAK"
    pivotType := "REGULAR"
    direction := "LOW"
    level := lastRegularLow
else if retestBrokenResistance
    eventType := "TOUCH"
    pivotType := "RETEST"
    direction := "LOW"  // Agora √© suporte (ex-resist√™ncia)
    level := brokenResistance
else if retestBrokenSupport
    eventType := "TOUCH"
    pivotType := "RETEST"
    direction := "HIGH"  // Agora √© resist√™ncia (ex-suporte)
    level := brokenSupport
else if touchRegularHigh
    eventType := "TOUCH"
    pivotType := "REGULAR"
    direction := "HIGH"
    level := lastRegularHigh
else if touchRegularLow
    eventType := "TOUCH"
    pivotType := "REGULAR"
    direction := "LOW"
    level := lastRegularLow
else if touchMissedHigh
    eventType := "TOUCH"
    pivotType := "MISSED"
    direction := "HIGH"
    level := lastMissedHigh
else if touchMissedLow
    eventType := "TOUCH"
    pivotType := "MISSED"
    direction := "LOW"
    level := lastMissedLow

// Detectar timeframe atual
currentTF = timeframe.period

// Construir timestamp
timestamp = str.format("{0,date,yyyy-MM-dd} {0,time,HH:mm:ss}", timenow)

// Construir JSON para webhook
alertMessage = not na(eventType) ? '{"action":"USDT_D_AUTO_EVENT","timeframe":"' + currentTF + '","eventType":"' + eventType + '","pivotInfo":{"type":"' + pivotType + '","direction":"' + direction + '","level":' + str.tostring(level, '#.####') + ',"pivotLength":' + str.tostring(length) + '},"dominance":' + str.tostring(close, '#.####') + ',"timestamp":"' + timestamp + '"}' : na

// Condi√ß√£o de alerta unificada
alertCondition = not na(eventType)

// Alerta √∫nico com JSON din√¢mico (freq_once_per_bar garante disparo √∫nico)
if alertCondition
    alert(alertMessage, alert.freq_once_per_bar)

// ============================================
// PLOTAGEM DE DEBUG (OPCIONAL)
// ============================================
// Descomentar para debug
// plot(lastRegularHigh, "Last Regular High", color=color.new(color.red, 80), linewidth=1, style=plot.style_circles)
// plot(lastRegularLow, "Last Regular Low", color=color.new(color.green, 80), linewidth=1, style=plot.style_circles)
// plot(brokenResistance, "Broken Resistance (now Support)", color=color.new(color.blue, 70), linewidth=2, style=plot.style_cross)
// plot(brokenSupport, "Broken Support (now Resistance)", color=color.new(color.orange, 70), linewidth=2, style=plot.style_cross)
