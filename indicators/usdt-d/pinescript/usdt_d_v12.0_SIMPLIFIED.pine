//@version=6
// ============================================
// USDT.D MONITOR v12.0 - LUXALGO EDITION [SIMPLIFIED]
// ============================================
// Autor: CryptoMind IA
// VersÃ£o: 12.0 (Simplificada - 8 CenÃ¡rios Corretos)
// Data: 19/01/2026
//
// CHANGELOG v12.0:
// âœ… Alertas disparam apenas UMA vez no momento exato do evento
// âœ… LÃ³gica profissional com crossover/crossunder
// âœ… 8 cenÃ¡rios corretos: TOUCH/BREAK x REGULAR/MISSED x HIGH/LOW
// âœ… Removida lÃ³gica redundante de RETEST
// âœ… 100% compatÃ­vel com v11.0 (mesma visualizaÃ§Ã£o)
//
// Baseado no algoritmo LuxAlgo de Pivot Points & Missed Reversals
// ============================================

indicator("USDT.D Monitor v12.0 [LuxAlgo Edition]", overlay=true, max_labels_count=500, max_lines_count=500, max_bars_back=500)

// ============================================
// INPUTS
// ============================================
length = input.int(50, 'Pivot Length', minval=1, tooltip='Tamanho da janela para detecÃ§Ã£o de pivots')

show_reg = input.bool(true, 'Mostrar Pivots Regulares', inline='inline1')
reg_ph_css = input.color(#ef5350, 'ResistÃªncia', inline='inline1')
reg_pl_css = input.color(#26a69a, 'Suporte', inline='inline1')

show_miss = input.bool(true, 'Mostrar ReversÃµes Perdidas', inline='inline2')
miss_ph_css = input.color(#ef5350, 'ResistÃªncia', inline='inline2')
miss_pl_css = input.color(#26a69a, 'Suporte', inline='inline2')

label_css = input.color(color.white, 'Cor do Texto')
touchTolerance = input.float(0.02, 'TolerÃ¢ncia de Toque (%)', minval=0.01, step=0.01)

// ============================================
// VARIÃVEIS PRINCIPAIS
// ============================================
var line zigzag = na
var line ghost_level = na
var float max = 0.
var float min = 0.
var int max_x1 = 0
var int min_x1 = 0
var float follow_max = 0.
var int follow_max_x1 = 0
var float follow_min = 0.
var int follow_min_x1 = 0
var int os = 0
var float py1 = 0.
var int px1 = 0

// VariÃ¡veis para alertas
var float lastRegularHigh = na
var float lastRegularLow = na
var float lastMissedHigh = na
var float lastMissedLow = na

// ============================================
// DETECÃ‡ÃƒO DE PIVOTS
// ============================================
n = bar_index
ph = ta.pivothigh(length, length)
pl = ta.pivotlow(length, length)

max := math.max(high[length], max)
min := math.min(low[length], min)
follow_max := math.max(high[length], follow_max)
follow_min := math.min(low[length], follow_min)

if max > max[1]
    max_x1 := n - length
    follow_min := low[length]

if min < min[1]
    min_x1 := n - length    
    follow_max := high[length]

if follow_min < follow_min[1]
    follow_min_x1 := n - length

if follow_max > follow_max[1]
    follow_max_x1 := n - length

line.set_x2(ghost_level[1], n)

// ============================================
// PROCESSAR PIVOT HIGH
// ============================================
if not na(ph)
    if show_miss
        if os[1] == 1
            label.new(min_x1, min, 'ðŸ‘»', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(min, '#.####'))
            
            zigzag := line.new(px1, py1, min_x1, min, color=miss_ph_css, style=line.style_dashed)
            px1 := min_x1
            py1 := min
            
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_pl_css, 50), width=2)
            
            lastMissedLow := min
            
        else if ph < max
            label.new(max_x1, max, 'ðŸ‘»', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(max, '#.####'))
            label.new(follow_min_x1, follow_min, 'ðŸ‘»', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(min, '#.####'))
            
            zigzag := line.new(px1, py1, max_x1, max, color=miss_pl_css, style=line.style_dashed)
            px1 := max_x1
            py1 := max
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_ph_css, 50), width=2)
            
            zigzag := line.new(px1, py1, follow_min_x1, follow_min, color=miss_ph_css, style=line.style_dashed)
            px1 := follow_min_x1
            py1 := follow_min
            line.set_x2(ghost_level, px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_pl_css, 50), width=2)
            
            lastMissedHigh := max
            lastMissedLow := follow_min

    if show_reg
        label.new(n - length, ph, 'â–¼', textcolor=label_css, color=reg_ph_css, style=label.style_label_down, size=size.small,
          tooltip=str.tostring(ph, '#.####'))
        zigzag := line.new(px1, py1, n - length, ph, color=miss_pl_css, style=ph < max or os[1] == 1 ? line.style_dashed : line.style_solid)
    
    lastRegularHigh := ph
    
    py1 := ph
    px1 := n - length
    os := 1
    max := ph
    min := ph

// ============================================
// PROCESSAR PIVOT LOW
// ============================================
if not na(pl)
    if show_miss  
        if os[1] == 0
            label.new(max_x1, max, 'ðŸ‘»', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(max, '#.####'))
            
            zigzag := line.new(px1, py1, max_x1, max, color=miss_pl_css, style=line.style_dashed)
            px1 := max_x1
            py1 := max
            
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_ph_css, 50), width=2)
            
            lastMissedHigh := max
            
        else if pl > min
            label.new(follow_max_x1, follow_max, 'ðŸ‘»', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(max, '#.####'))
            label.new(min_x1, min, 'ðŸ‘»', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(min, '#.####'))
            
            zigzag := line.new(px1, py1, min_x1, min, color=miss_ph_css, style=line.style_dashed)
            px1 := min_x1
            py1 := min
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_pl_css, 50), width=2)
            
            zigzag := line.new(px1, py1, follow_max_x1, follow_max, color=miss_pl_css, style=line.style_dashed)
            px1 := follow_max_x1
            py1 := follow_max
            line.set_x2(ghost_level, px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_ph_css, 50), width=2)
            
            lastMissedHigh := follow_max
            lastMissedLow := min

    if show_reg
        label.new(n - length, pl, 'â–²', textcolor=label_css, color=reg_pl_css, style=label.style_label_up, size=size.small,
          tooltip=str.tostring(pl, '#.####'))
        zigzag := line.new(px1, py1, n - length, pl, color=miss_ph_css, style=pl > min or os[1] == 0 ? line.style_dashed : line.style_solid)
    
    lastRegularLow := pl
    
    py1 := pl
    px1 := n - length
    os := 0
    max := pl
    min := pl

// ============================================
// ESTIMATIVA EM TEMPO REAL
// ============================================
var label lbl = na
if barstate.islast
    x = 0
    y = 0.
    
    prices = array.new<float>(0)
    prices_x = array.new<int>(0)
    
    for i = 0 to n - px1 - 1
        array.push(prices, os == 1 ? low[i] : high[i])
        array.push(prices_x, n - i)
    
    label.delete(lbl[1])
    
    if os == 1
        y := array.min(prices)
        x := array.get(prices_x, array.indexof(prices, y))
        
        if show_miss
            lbl := label.new(x, y, 'ðŸ‘»', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(y, '#.####'))
    else
        y := array.max(prices)
        x := array.get(prices_x, array.indexof(prices, y))
        
        if show_miss
            lbl := label.new(x, y, 'ðŸ‘»', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(y, '#.####'))
            
    if show_miss
        line.delete(line.new(px1, py1, x, y, color=os == 1 ? miss_ph_css : miss_pl_css, style=line.style_dashed)[1])
    
    line.delete(line.new(x, y, n, y, color=color.new(os == 1 ? miss_ph_css : miss_pl_css, 50), width=2)[1])

// ============================================
// SISTEMA DE ALERTAS v12.0 (8 CENÃRIOS)
// ============================================

tolerance = close * touchTolerance / 100

// ============================================
// DETECÃ‡ÃƒO DE EVENTOS ÃšNICOS
// ============================================

// ROMPIMENTOS (usando crossover/crossunder)
bool breakRegularHigh = not na(lastRegularHigh) and ta.crossover(close, lastRegularHigh + tolerance)
bool breakRegularLow = not na(lastRegularLow) and ta.crossunder(close, lastRegularLow - tolerance)
bool breakMissedHigh = not na(lastMissedHigh) and ta.crossover(close, lastMissedHigh + tolerance)
bool breakMissedLow = not na(lastMissedLow) and ta.crossunder(close, lastMissedLow - tolerance)

// TOQUES (apenas se nÃ£o houve BREAK)
bool touchRegularHigh = false
bool touchRegularLow = false
bool touchMissedHigh = false
bool touchMissedLow = false

if not (breakRegularHigh or breakRegularLow or breakMissedHigh or breakMissedLow)
    if not na(lastRegularHigh)
        touchRegularHigh := close >= lastRegularHigh - tolerance and close <= lastRegularHigh + tolerance and close[1] < lastRegularHigh - tolerance
    
    if not na(lastRegularLow)
        touchRegularLow := close >= lastRegularLow - tolerance and close <= lastRegularLow + tolerance and close[1] > lastRegularLow + tolerance
    
    if not na(lastMissedHigh)
        touchMissedHigh := close >= lastMissedHigh - tolerance and close <= lastMissedHigh + tolerance and close[1] < lastMissedHigh - tolerance
    
    if not na(lastMissedLow)
        touchMissedLow := close >= lastMissedLow - tolerance and close <= lastMissedLow + tolerance and close[1] > lastMissedLow + tolerance

// ============================================
// CONSTRUÃ‡ÃƒO DO ALERTA
// ============================================

string eventType = na
string pivotType = na
string direction = na
float level = na

// Prioridade: BREAK > TOUCH
if breakRegularHigh
    eventType := "BREAK"
    pivotType := "REGULAR"
    direction := "HIGH"
    level := lastRegularHigh
else if breakRegularLow
    eventType := "BREAK"
    pivotType := "REGULAR"
    direction := "LOW"
    level := lastRegularLow
else if breakMissedHigh
    eventType := "BREAK"
    pivotType := "MISSED"
    direction := "HIGH"
    level := lastMissedHigh
else if breakMissedLow
    eventType := "BREAK"
    pivotType := "MISSED"
    direction := "LOW"
    level := lastMissedLow
else if touchRegularHigh
    eventType := "TOUCH"
    pivotType := "REGULAR"
    direction := "HIGH"
    level := lastRegularHigh
else if touchRegularLow
    eventType := "TOUCH"
    pivotType := "REGULAR"
    direction := "LOW"
    level := lastRegularLow
else if touchMissedHigh
    eventType := "TOUCH"
    pivotType := "MISSED"
    direction := "HIGH"
    level := lastMissedHigh
else if touchMissedLow
    eventType := "TOUCH"
    pivotType := "MISSED"
    direction := "LOW"
    level := lastMissedLow

currentTF = timeframe.period
timestamp = str.format("{0,date,yyyy-MM-dd} {0,time,HH:mm:ss}", timenow)

alertMessage = not na(eventType) ? '{"action":"USDT_D_AUTO_EVENT","timeframe":"' + currentTF + '","eventType":"' + eventType + '","pivotInfo":{"type":"' + pivotType + '","direction":"' + direction + '","level":' + str.tostring(level, '#.####') + ',"pivotLength":' + str.tostring(length) + '},"dominance":' + str.tostring(close, '#.####') + ',"timestamp":"' + timestamp + '"}' : na

alertCondition = not na(eventType)

if alertCondition
    alert(alertMessage, alert.freq_once_per_bar)
