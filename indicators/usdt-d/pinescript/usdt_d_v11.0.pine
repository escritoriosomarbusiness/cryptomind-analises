//@version=6
// ============================================
// USDT.D MONITOR v11.0 - LUXALGO EDITION
// ============================================
// Baseado no algoritmo LuxAlgo de Pivot Points & Missed Reversals
// Detecta automaticamente suporte/resist√™ncia e revers√µes perdidas
// Sistema de alertas otimizado para webhook n8n ‚Üí Telegram

indicator("USDT.D Monitor v11.0 [LuxAlgo Edition]", overlay=true, max_labels_count=500, max_lines_count=500, max_bars_back=500)

// ============================================
// INPUTS
// ============================================
length = input.int(50, 'Pivot Length', minval=1, tooltip='Tamanho da janela para detec√ß√£o de pivots. Valores maiores = revers√µes mais significativas')

show_reg = input.bool(true, 'Mostrar Pivots Regulares', inline='inline1')
reg_ph_css = input.color(#ef5350, 'Resist√™ncia', inline='inline1')
reg_pl_css = input.color(#26a69a, 'Suporte', inline='inline1')

show_miss = input.bool(true, 'Mostrar Revers√µes Perdidas', inline='inline2')
miss_ph_css = input.color(#ef5350, 'Resist√™ncia', inline='inline2')
miss_pl_css = input.color(#26a69a, 'Suporte', inline='inline2')

label_css = input.color(color.white, 'Cor do Texto')

// Configura√ß√µes de alerta
touchTolerance = input.float(0.02, 'Toler√¢ncia de Toque (%)', minval=0.01, step=0.01, tooltip='Dist√¢ncia percentual para considerar toque no n√≠vel')

// ============================================
// VARI√ÅVEIS PRINCIPAIS
// ============================================
var line zigzag = na
var line ghost_level = na
var float max = 0.
var float min = 0.
var int max_x1 = 0
var int min_x1 = 0
var float follow_max = 0.
var int follow_max_x1 = 0
var float follow_min = 0.
var int follow_min_x1 = 0
var int os = 0
var float py1 = 0.
var int px1 = 0

// Vari√°veis para alertas
var float lastRegularHigh = na
var float lastRegularLow = na
var float lastMissedHigh = na
var float lastMissedLow = na

// ============================================
// DETEC√á√ÉO DE PIVOTS
// ============================================
n = bar_index
ph = ta.pivothigh(length, length)
pl = ta.pivotlow(length, length)

// Rastreamento cont√≠nuo de m√°ximos e m√≠nimos
max := math.max(high[length], max)
min := math.min(low[length], min)
follow_max := math.max(high[length], follow_max)
follow_min := math.min(low[length], follow_min)

// Atualizar posi√ß√µes dos extremos
if max > max[1]
    max_x1 := n - length
    follow_min := low[length]

if min < min[1]
    min_x1 := n - length    
    follow_max := high[length]

if follow_min < follow_min[1]
    follow_min_x1 := n - length

if follow_max > follow_max[1]
    follow_max_x1 := n - length

// ============================================
// ESTENDER N√çVEIS FANTASMA
// ============================================
line.set_x2(ghost_level[1], n)

// ============================================
// PROCESSAR PIVOT HIGH
// ============================================
if not na(ph)
    if show_miss
        if os[1] == 1
            // Dois pivot highs consecutivos ‚Üí Missed reversal LOW
            label.new(min_x1, min, 'üëª', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(min, '#.####'))
            
            zigzag := line.new(px1, py1, min_x1, min, color=miss_ph_css, style=line.style_dashed)
            px1 := min_x1
            py1 := min
            
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_pl_css, 50), width=2)
            
            // Registrar missed reversal para alertas
            lastMissedLow := min
            
        else if ph < max
            // Pivot high menor que m√°ximo anterior ‚Üí Missed reversals
            label.new(max_x1, max, 'üëª', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(max, '#.####'))
            label.new(follow_min_x1, follow_min, 'üëª', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(min, '#.####'))
            
            zigzag := line.new(px1, py1, max_x1, max, color=miss_pl_css, style=line.style_dashed)
            px1 := max_x1
            py1 := max
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_ph_css, 50), width=2)
            
            zigzag := line.new(px1, py1, follow_min_x1, follow_min, color=miss_ph_css, style=line.style_dashed)
            px1 := follow_min_x1
            py1 := follow_min
            line.set_x2(ghost_level, px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_pl_css, 50), width=2)
            
            // Registrar missed reversals para alertas
            lastMissedHigh := max
            lastMissedLow := follow_min

    if show_reg
        label.new(n - length, ph, '‚ñº', textcolor=label_css, color=reg_ph_css, style=label.style_label_down, size=size.small,
          tooltip=str.tostring(ph, '#.####'))
        zigzag := line.new(px1, py1, n - length, ph, color=miss_pl_css, style=ph < max or os[1] == 1 ? line.style_dashed : line.style_solid)
    
    // Registrar pivot regular para alertas
    lastRegularHigh := ph
    
    py1 := ph
    px1 := n - length
    os := 1
    max := ph
    min := ph

// ============================================
// PROCESSAR PIVOT LOW
// ============================================
if not na(pl)
    if show_miss  
        if os[1] == 0
            // Dois pivot lows consecutivos ‚Üí Missed reversal HIGH
            label.new(max_x1, max, 'üëª', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(max, '#.####'))
            
            zigzag := line.new(px1, py1, max_x1, max, color=miss_pl_css, style=line.style_dashed)
            px1 := max_x1
            py1 := max
            
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_ph_css, 50), width=2)
            
            // Registrar missed reversal para alertas
            lastMissedHigh := max
            
        else if pl > min
            // Pivot low maior que m√≠nimo anterior ‚Üí Missed reversals
            label.new(follow_max_x1, follow_max, 'üëª', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(max, '#.####'))
            label.new(min_x1, min, 'üëª', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(min, '#.####'))
            
            zigzag := line.new(px1, py1, min_x1, min, color=miss_ph_css, style=line.style_dashed)
            px1 := min_x1
            py1 := min
            line.set_x2(ghost_level[1], px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_pl_css, 50), width=2)
            
            zigzag := line.new(px1, py1, follow_max_x1, follow_max, color=miss_pl_css, style=line.style_dashed)
            px1 := follow_max_x1
            py1 := follow_max
            line.set_x2(ghost_level, px1)
            ghost_level := line.new(px1, py1, px1, py1, color=color.new(reg_ph_css, 50), width=2)
            
            // Registrar missed reversals para alertas
            lastMissedHigh := follow_max
            lastMissedLow := min

    if show_reg
        label.new(n - length, pl, '‚ñ≤', textcolor=label_css, color=reg_pl_css, style=label.style_label_up, size=size.small,
          tooltip=str.tostring(pl, '#.####'))
        zigzag := line.new(px1, py1, n - length, pl, color=miss_ph_css, style=pl > min or os[1] == 0 ? line.style_dashed : line.style_solid)
    
    // Registrar pivot regular para alertas
    lastRegularLow := pl
    
    py1 := pl
    px1 := n - length
    os := 0
    max := pl
    min := pl

// ============================================
// ESTIMATIVA EM TEMPO REAL
// ============================================
var label lbl = na
if barstate.islast
    x = 0
    y = 0.
    
    prices = array.new<float>(0)
    prices_x = array.new<int>(0)
    
    for i = 0 to n - px1 - 1
        array.push(prices, os == 1 ? low[i] : high[i])
        array.push(prices_x, n - i)
    
    label.delete(lbl[1])
    
    if os == 1
        y := array.min(prices)
        x := array.get(prices_x, array.indexof(prices, y))
        
        if show_miss
            lbl := label.new(x, y, 'üëª', color=miss_pl_css, style=label.style_label_up, size=size.small,
              tooltip=str.tostring(y, '#.####'))
    else
        y := array.max(prices)
        x := array.get(prices_x, array.indexof(prices, y))
        
        if show_miss
            lbl := label.new(x, y, 'üëª', color=miss_ph_css, style=label.style_label_down, size=size.small,
              tooltip=str.tostring(y, '#.####'))
            
    if show_miss
        line.delete(line.new(px1, py1, x, y, color=os == 1 ? miss_ph_css : miss_pl_css, style=line.style_dashed)[1])
    
    line.delete(line.new(x, y, n, y, color=color.new(os == 1 ? miss_ph_css : miss_pl_css, 50), width=2)[1])

// ============================================
// SISTEMA DE ALERTAS
// ============================================

// Calcular toler√¢ncia em valor absoluto
tolerance = close * touchTolerance / 100

// Detectar toques e rompimentos
touchRegularHigh = not na(lastRegularHigh) and close >= lastRegularHigh - tolerance and close <= lastRegularHigh + tolerance
touchRegularLow = not na(lastRegularLow) and close >= lastRegularLow - tolerance and close <= lastRegularLow + tolerance
touchMissedHigh = not na(lastMissedHigh) and close >= lastMissedHigh - tolerance and close <= lastMissedHigh + tolerance
touchMissedLow = not na(lastMissedLow) and close >= lastMissedLow - tolerance and close <= lastMissedLow + tolerance

breakRegularHigh = not na(lastRegularHigh) and close > lastRegularHigh + tolerance
breakRegularLow = not na(lastRegularLow) and close < lastRegularLow - tolerance

// Determinar tipo de evento
eventType = breakRegularHigh or breakRegularLow ? "BREAK" : "TOUCH"
pivotType = touchMissedHigh or touchMissedLow ? "MISSED" : "REGULAR"
direction = (touchRegularHigh or touchMissedHigh or breakRegularHigh) ? "HIGH" : "LOW"
level = (touchRegularHigh or breakRegularHigh) ? lastRegularHigh : (touchRegularLow or breakRegularLow) ? lastRegularLow : touchMissedHigh ? lastMissedHigh : lastMissedLow

// Detectar timeframe atual
currentTF = timeframe.period

// Construir timestamp
timestamp = str.format("{0,date,yyyy-MM-dd} {0,time,HH:mm:ss}", timenow)

// Construir JSON para webhook
alertMessage = '{"action":"USDT_D_AUTO_EVENT","timeframe":"' + currentTF + '","eventType":"' + eventType + '","pivotInfo":{"type":"' + pivotType + '","direction":"' + direction + '","level":' + str.tostring(level, '#.####') + ',"pivotLength":' + str.tostring(length) + '},"dominance":' + str.tostring(close, '#.####') + ',"timestamp":"' + timestamp + '"}' 

// Condi√ß√£o de alerta unificada
alertCondition = touchRegularHigh or touchRegularLow or touchMissedHigh or touchMissedLow or breakRegularHigh or breakRegularLow

// Alerta √∫nico com JSON din√¢mico
if alertCondition
    alert(alertMessage, alert.freq_once_per_bar)

// ============================================
// PLOTAGEM DE DEBUG (OPCIONAL)
// ============================================
// plot(lastRegularHigh, "Last Regular High", color=color.new(color.red, 80), linewidth=1, style=plot.style_circles)
// plot(lastRegularLow, "Last Regular Low", color=color.new(color.green, 80), linewidth=1, style=plot.style_circles)
